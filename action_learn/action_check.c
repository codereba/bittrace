/*
 *
 * Copyright 2010 JiJie Shi(weixin:AIChangeLife)
 *
 * This file is part of bittrace.
 *
 * bittrace is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * bittrace is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with bittrace.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
 
#include "common_func.h"
#include "ring0_2_ring3.h"
#include "action_type.h"
#include "action_check.h"
#include "action_source.h"
#include "static_policy.h"
#include "action_group_policy.h"
#include "action_policy_common.h"
#include "action_learn.h"

group_policy_nfa group_nfa; 

//#define IMPORTANT_FILE_PATH 

/********************************************************
action abstraction layer:
1.instruction and memory data
2.api and parameters
3.action detail type
4.action type
********************************************************/

/***********************************************************
标记式行为状态：
通过对行为进行策略匹配分析，对匹配结果打入相应的标记。通过
最终形成标记集合来表示行为源的属性。（分析的目标是得到行为
源的属性）
***********************************************************/

/**********************************************************
当前安全方案潮流分析：
1.使用预设固定简单判断策略来保证计算机执行流安全性。
2.使用智能分析策略来保证计算机执行流安全性。
***********************************************************/
/****
现在只能做到为行为源的分析和处理，和对行为集的间接，简单分析和处理。
使用智能分析方式时，必须使目标行为源做出一些行为，如果没有重定向技术
支持，则行为源在分析结果前的破坏性行为将不会被阻止。
重定向技术具有一定的复杂性，全面开发需要一定的时间。时间与破坏行为两
者需要权衡。
****/

/**************************************************************
功能和用户交互运行过程，用户需求实现情况分析：
1.
监视，分析功能：
全面全面系统的网络，文件，硬盘，系统对象行为日志，实时输出界面。
屏幕中显示的内容包括：
1.行为名称
2.行为源名称
3.行为目标名称
4.行为属性（其中包括，权限，堆栈跟踪等）
	1.行为数据（其中包括具体数据内容和长度）
	2.行为数据分析
		1.智能分析，通过对行为源行为分析得出
		2.人工预置规则分析，通过预先设置的规则进行分析。（行为
		源ID标识）

用户交互：
设置跟踪行为源的范围，几个进程（进程组），1个进程，全部系统。
设置跟踪行为源的过滤条件，结果，对象名称，属性值等。
*
1.设置跟踪级别
2.是否加入数据分析
3.数据的最大长度设置
3.是否加入数据智能解析

用户分类：
1.1级用户，不懂计算机，不能对计算机行为进行任何分析和控制。
2.2级用户，对计算机有基本了解，可以进行描述精楚，内容简单的行为
分析和控制。
3.3级用户，对计算机各种行为机制理解，可以进行复杂行为的分析和控制。

用户需求实现分析：
针对2,3级别用户群，辅助其处理计算机运行问题，找出问题原因。分析
当前计算机动态的运行状态。

实现架构分析:
1.安全功能基础架构:
	1.全面的各种类型行为抓取，控制系统。
	2.全面的各种类型行为的智能策略，预置策略。
2.日志输出界面，模块。
3.用户控制，显示界面。

2.控制，分析功能：
实现架构分析：
1.安全功能基础架构
2.智能策略，预置行为，数据分析策略。
3.策略响应结果集。
4.无法精确确定响应结果时，用户辅助判断界面。

用户需求实现分析：
针对1，2，3级别用户群，直接监测，跟踪系统各种类型的行为，对行为
进行智能分析，尽量直接做出响应。（透明处理：在用户没有感觉的情况下，
对破坏行为进行处理）。在不能精确处理的时候，以极简的方式得到用户
的辅助。可以满足用户在使用计算机时，遇到的各种，网络，文件系统，
硬盘，系统数据结构的破坏性行为的阻止处理。
破坏行为分析：
破坏行为分类：
1.信息窃取
2.数据破坏

1.信息窃取：
加入运行破坏程序对系统关键进程进行注入，对数据进行读取，传输。
分级：
1.4级，用户不可泄露的机密数据，隐私数据。
2.3级，用户数据泄露不能产生致命影响。
3.2级，用户数据泄露不重要，有一些不利因素。
4.1级，用户希望数据可以发布。

2.数据破坏：
1.4级，致命
2.3级，一般
3.2级，不利
4.1级，希望

用户群，需求度分析：
1.用户群包括所有计算机用户，每一台计算机都具有用户不希望泄露的数据。
2.需求度因用户数据的重要程度而不同，通常每台计算机都具有2，3级内的关键数据。

用户，需求量庞大。需求度一般。

是否做为功能实现：是，重要性2级。

2.系统状态监视，维护。
1.对系统各个层次，方面的状态进行分析。
	1.CPU资源占用。
		1.找出不正确占用CPU的进程，阻止占用行为。
	2.关键系统基础文件，数据的保护，找出破坏行为，进行阻止。

2.对各种关键程序进行各个层次，方面的状态监控，分析，处理。
	1.程序运行功能的正确性，进行分析，找出不正确运行行为，进行
	阻止。

	1，2，3级用户需求量大，需求度都高。

当前用户数据安全，系统安全，应用安全功能实现方案，用户问题，需求实现度分析：
1.杀毒功能
	1.金山杀毒，固定策略（二进制数据特征码），动态策略相结合的阻止，删除破坏行为功能。
	2.360杀毒，与金山实现方式相同。
	3.360安全卫士，有部分动，静态杀毒功能。具有部分系统功能错误静态（可能有少量动态）分析，修正功能。
	4.可能最好的策略集式分析方案在HURONG。但它的稳定性，错误修正率是未知的，没有实际成功的测试经验。

2.用户的安全问题可以得到大部分处理（敢赔功能，内部具有一套稳定的，命中率较高的安全保护机制（可能是有意强化或本身稳定性比较高）），部分（低于50%）的系统功能错误可以得到处理（静态）。
  对于用户的数据安全可以得到间接的安全，大部分的安全保护。
  对于另一部分没有得到注意和支持的系统功能错误，没有相应的修正功能。动态分析具有一定程度的智能处理功能。
  （比较低）。
  不能满足2，3级用户需要分析了解系统行为的需求。

主要竞争对手分析：
HURONG:
开发人员应该在10人左右（不能确定其中的稳定的人数有多少），功能具有一定经验和水平。现在可能还有没有实现可以运营的收益，还在开消阶段。
金山杀毒：
开发人员在50-100人左右（稳定工作人员在50人左右），功能全面，反应，开发速度高。

竞争方案
可以对它的所有细节进行全面的分析，全面的分析工作需要半年到一年内，每天8小时高投入的分析工作。

由于其没有实现收益，有参考价值，但不会做为竞争对象。
金山杀毒将做为竞争，参考，分析对象。
竞争方式是从小功能，做全面，精确，精巧。尽力提高超越难度（5级）。
绝对不能以大而全的方式进行产品设计，开发。全部的设计，开发过程都从人力时间，效率出发，进行精确的计算。

开发原则：
最佳实现用户需求，最简，最快，越核心功能越佳，越次要功能时间，FEATURE越低。

弱点分析：
金山杀毒的动态分析功能，没有分析过程展示，不能满足2，3级用户需求。（价值2，实现复杂度2，超越复杂度1.8）。
金山杀毒静态分析功能，没有足够人力不可以竞争成功。
金山杀毒动态分析功能，是隐藏式的，不能确定其分析能力级别。可能比较低，成为弱点。

竞争力分析：
1.可以实现功能
	1.可以实现行为集分析信息输出，让2，3级用户了解系统中行为过程。
	2.不能确定可以实现比金山杀毒更强大的动态分析能力。同时整体上的
	杀毒，保护功能从整体上不能超越。（人力时间太少）

开发效果估计：
1.可以赢得部分2，3级用户的使用。在行业内属于创新，同时在行业内达到最佳，具有一定竞争力。
2.但无法赢得1级用户，和只需要保护功能，没有分析需求的2，3级用户，因为无法超越金山杀毒的保护功能。
即使动态分析保护功能足够强大，也很难在最终的保护功能和效果上和金山杀毒竞争。

开发时间估计：
1.已经建立成功行为抓取系统主要框架。
2.设计建立系统行为分析系统。需要1个月开发第1版本，3个月左右的零散时间的完善，升级，构成第1稳定版本。
3.分析，设计，植入策略集。需要2个星期分析，设计，开发。2个星期进行完善，联调，测试，构成第1稳定版本。
4.1个星期组织用户界面。
5.3个星期所有功能联调，完善，实现整个功能集的稳定运行。
6.进行发布。

估计总共需要6个月的时间来完成开发。

开发价值评估：
1.赢得部分2，3级用户。
2.开发成功性90%以上。
3.开发回报，推广方式，自然推广。积累一定量（10万）的用户群需要一定的时间。初步免费+赞助模式。免费第1版本回报比较慢。
4.竞争力50%之内，如果不能连续升级，可以被金山等软件超越。竞争对象比较少，因为开发基础架构技术难度大，只能与具有较多
经验的行业内的竞争对手竞争。
5.一定比例用户+一定积累用户速度+50%行业内有限对手竞争力-6个月基本全工的开发时间。是否值得进行？

其它领域功能价值分析：
案例：
懒人听书，开发技术要求不高，具有一定创意+高质后备资源=短时间积累百万用户群。
总开发时间估计：
1.1个人力1个月之内，可以完成所有的开发+调试，形成第1个版本。
2.资源积累需要1-6个月。


总有两条开发线路：
1.创意线路：需要资源积累较高的成本。
2.技术线路：需要大量的开发人力时间。

技术占创业成功原因的20%-30%，其它资源，设计，创意，应用资源（关系资源），推广，销售占至少70%。



白名单功能：
用户需求分析：
可以对行为进行人工预置控制，但是控制方式粗糙，简单，使用户无法方便
，高效的使用计算机各种应用功能。
用户群，需求度分析：
1.关键安全性，应用单一行业，用户。需求度高。
2.一般用户有基础需求，但实现技术和效果不能被接受。需求度为负低。

白名单是否实现：
1否，但可以加入小型的相关技术，理念。


**************************************************************/

/**************************************************************
用户体验过程，UI分析：
1.主界面设计：
	1.系统行为分析
	2.策略设计
	3.工具箱
	4.关于

	1.系统行为分析
		1.列出系统中的所有行为
		2.列出系统某个，某几个行为源的行为，或使用其它方式进行过滤。
		行为源包括：（进程集（JOBS），父子进程集，单个进程，单个线程）。

		3.对行为源的行为流进行分析，找出匹配的行为集，和行为集的含义。
		4.对数据流进行抓取，对数据块进行翻译。
		5.对分析级别进行设置。
		6.SQL查询语句支持。（高级功能）

	2.策略设计
		1.列出系统各个方面，层次的策略。
		2.可以指定行为链策略的含义。
		3.可以指定行为链策略响应方式（阻止，允许）。

	3.工具箱
		1.可以列出各种辅助工具（远程控制，漏洞修复等）。

	4.关于

	1.用户体验分析：
		1.2，3级用户需要将系统行为，其数据流进行清楚的分解，列出。
		可以达到市场中最佳效果。
		2.1级用户需要直接对所有的破坏行为，行为源进行处理。实现
		功能有限。第1版本不能超越任何一个专业杀毒软件。
		完善方法：
		1.对动态分析进行完善，超越静态分析。（复杂度太高）。
		2.加入静态分析，可以自行开发（人力时要求太高），或与其它
		杀毒厂商合作。

	2.利润分析：
		1.累积10万需求3，4，5级用户，通过共享授权，广告宣传等方式得到3000/月利润。
		自然推广方式，可能需要半年的时间，同时需要不断的快速升级。

	3.产品核心功能，创意
		1.核心功能是动态分析，创新是数据流和行为链动态分析。实现难度9级，业内实现难度3级。

	4.补充
	用户必然需要方便，极简的自定义策略方式来对其需要处理的特殊行为进行分析。强大，极简的自
	定义策略方式。

	在动态分析之外，用户还需要什么功能？
**************************************************************/

/**************************************************************
软件架构设计：
1.灵活模块插件架构
2.模块扩展架构
3.极简模块扩展SDK

设计模式：
包装模式

核心算法：
B树
策略集状态机
**************************************************************/

/**************************************************************
将来需要新开发的组件：
1.SANDBOX：
	1.研究设计虚拟机指令支持(COMODO)。

**************************************************************/

/**************************************************************
支持的分析，决策行为类型：
1.改写系统关键数据，行为。
2.
**************************************************************/

/*************************************************************
相关研究：
1.公安部计算机等级保护四级：
	1.破坏程序不可以被落地。
	2.破坏程序不可以被执行。
	3.破坏程序即使执行，也不能产生破坏。

BITSAFE的对应功能：
	1.破坏程序不可以被落地不能直接实现，因为事先需要黑名单或白名
	单库（静态分析病毒库是一种）。但可以入SANDBOX先分析后再立即
	删除。实现复杂更大，对此功能只能以这种间接方式实现。
	2.破坏程序不可以被执行，可能被实现，只要动态分析功能足够安全
	，包含了系统各个方面，策略集足够完善。
	3.破坏程序即使被执行，也不能产生破坏。可能被实现，只要只要
	动态分析功能足够安全，包含了系统各个方面，策略集足够完善，
	有阻止相应行为的响应即可。

安全级别最高，也是限制最大技术：
白名单 合适于安全要求不可出错的场所。
黑名单（静态病毒库） 合适于安全要求一般的场所。
动态分析 合适于安全标求一般更低的场所。

动态分析只具有有限的分析力（因为没有人功智能学习能力），
但实现的方式最为复杂。但可以将白名单的思想做为各种行的策略设计
于其中，实现白名单相近安全性。也就是说，可以通过策略使动态分析
成为白名单功能。

动态分析的解决的问题是使系统的运行回归于平衡，正确。分析，自动处理
各个方面，层次的系统错误（包括破坏功能）行为。

用户使用计算机的本质需求是执行一段具有需求功能的指令序列。而要达
到这个目的需要这些支持：
1.优秀，正确指令序列（可执行文件）资源下载源。
2.用户对可执行文件功能正确，完善，稳定性的分析能力。
3.外部分析功能，确保指令序列功能的正确性。（动态分析功能是主要
的实现技术之一，也最精确。还有静态分析病毒库系统）

外部分析功能，是实现非人工指令序列正确性判断的必须技术。
所以指令序列动态分析功能具有很大的用户需求量，和3，4，5级需求度。

用户的其它需求可能比较合适小范围的市场和用户群。还没有更多的用户
需求分析结果。

BITSAFE第1版本决定开发动态分析功能，执行以下开发流程：
1.动态策略系统
2.内核+应用层SANDBOX
3.接口功能集，基于设计好的用户体验过程。（加入灵活模块架构）
4.用户交互功能集
**************************************************************/

/****************************************************************
动态策略集开发过程：
1.每个行为源中具有一个行为状态描述信息结构。
2.
****************************************************************/

typedef struct _POLICY_NODE 
{
	LIST_ENTRY entry; 
	action_policy policy; 
	ULONG flags; 
}POLICY_NODE, *PPOLICY_NODE; 

/************************************************************************
current action analyze nfa version use process to be the unit of 
the action source.
************************************************************************/

/******************************************************************************
how can do the policy checking ?
1.one action bind one action check function.
2.all action use one checking function， this function checking all action 
by its type.
******************************************************************************/
/**************************************************************************
行为组策略内部结构:
1.建立一条行为策略链，中间所有的策略都是不同的。
2.触发过的策略和未触发的策略放在不同的链表中。
3.每当有新的行为发生时，都输入至策略链中进行检查。
4.每当有新的策略被触发时，都检查所有引用它的策略组，如果有策略组，它的所有
包含的策略都被触发过，则执行此策略组对应的响应。
5.每次输入相同的策略时，不添加新策略，而是建立和输入策略组的引用链接。
**************************************************************************/

/****************************************************************************
1.策略是一种全局的概念，整个系统中的所有的行为源共同使用同一套策略系统。
所以不合适对每一个行为源加入一个策略系统。
2.行为源会在一个时间范围之中发生一定数量的行为，进发的，或者有先后赶时间的。
3.行为源的行为模式匹配应该记录在这个行为源的行为状态记录结构中。

*****************************************************************************/

/****************************************************************
action checking mechanism design rule:
1.use more region rule
2.use simplest region rule description
3.use quickest algrithm for the comparing between the action and the rule
4.use fewest rule.
****************************************************************/

/***********************************************************************************
系统的行为流包括：
1文件
2注册表
3硬盘
4网络
5内存读写
6系统各型对象操作

行为对象：
主体
进程
线程
主体相关对象
用户
权限

客体
文件
注册表
硬盘
系统各型对象
内存

系统行为的代码解层次：
1.口头语言功能描述
2.连结代码+附属作用代码+api调用分析
3.纯代码分析(各层次API代码细节)

系统的行为流的分析层次：
1直接对行为的对象进行判断。
2对行为的
在调用文件IO的功能时，先进行权限的判断，加入了EXE文件的分析系统，判断此EXE文件是否具
有此文件相应的IO功能权限，如果没有，则拒绝此IO。
用户需求：
1将文件按照可访问的权限划分为：
	按用户来进行划分
	1所有用户，所有程序，在所有时间共享
	2私有用户可在特定的时机下访问

	按程序来进行划分（可能实际没有相应的需求）：
	2个别程序可以在特定时机下访问

我不了解系统里到底在什么工作，我需要保证系统关键的信息不被随便改动。

我不了解系统里到底在做什么工作，我不可以让任何对我的数据，系统，信息不利的程序运行

系统突然卡死，分析系统正在进行什么工作，有什么进程，各个进程正在进行什么工作。

对计算机有一定了解的用户：
我需要了解系统中所有的程序做了什么事情，具体读写了什么文件，注册表，网络，数据里面包括什么？

进程突然停止，分析出进程停止的原因：
抓取进程在停止前的行为流。

判断一个系统行为是否有效，需要使用如下信息：
1进程EXE文件
2被访问文件路径，注册表路径，或被访问信息路径
3具体的行为
4对此EXE文件的分析结果和用户的判断

人工分析系统行为的过程：
1.分析系统行为表象
2.抓取系统行为API和关键参数，关键数据
3.找出分析相应的代码段和相关代码，最终确定代码的具体细节功能是什么
4.做出反应行为判断

计算机辅助分析系统行为的过程：
1.人工分析系统行为表象
2.计算机内部抓取相关API调用，关键数据，甚至相关代码 
3.计算机使用直接API调用功能+关键数据策略来对相应的行为进行分析，找出相应的反应行为。
4.计算机使用API调用复合(多API调用序(一维序))策略来对相应的行为进行分析，找出相应的反应行为。
5.计算机使用API调用序+系统环境状态+特别数据+其它维度信息对相应的行为进行分析，找出相应的反应。
6.计算机使用API调用序+自动分析相关机器码(模式分析，直接分析)+其它维度的信息对相应的行为进行分析。
7.计算机无限维+自学习来对相应的行为进行分析
8.人工分析

BITSAFE需要实现的分析功能
1.API调用+关键数据=反应
2.API调用序+关键数据序=反应
3.API调用序+机器代码模式匹配=反应
//4.API调用序+机器代码序=反应

BITSAFE的基本架构：
基础功能
1.系统各类型，各层次行为抓取，抓取类型：1.前抓取(执行反应行为)2.后抓取(记录系统现实行为，
分析行为序。

中间功能(模式匹配):
2.对系统行为和行为序人工构造匹配模式和反应
注:将会涉及到非常多的系统模式分析，需要分析系统在各种情况下的行为序对应的功能意义。
(可以使用PROCMON来抓取系统行为)BITSAFE要提供强大的系统行为抓取功能。

表面功能(反应)
3.以用户需求的方式将信息和反应传达给用户

BITSAFE的未来架构:
1.对系统行为，行为序设计自学习基础策略。
2.行为反应自学习功能。

一层分析，相同反应集，参数和策略最多
二层分析，相同反应集，参数和策略居中
三层分析，相同反应集，参数和策略最少

***********************************************************************************/

/***********************************************************************************
1.系统行为链收集?
	1.系统行为是非常频繁和琐碎的，如何将其提炼为由独立系统行为组成的行为链
2.系统行为链匹配?
	1.哪些行为是最关键的，需要做为系统行为匹配比较的特征数值。
3.应该针对哪些系统问题定制系统行为模式。
	1.针对系统破坏行为(病毒)，大多数的安全软件的系统行为定制模式。

4.资料分析
	1.kab源码中的HIPS有系统行为链技术，它使用进程做为行为源单位。(使用线程是更加合理，现实的系统行为源单位)
	2.HUORONG使用线程做行为链管理单位

5.精确的值匹配模式是否能够识别实际中的系统行为?
	1.实际中要判断的行为具体一定的范围性和模糊性，这些特征如何进行值匹配运算?

5.系统行为链收集过程的破坏行为处理问题?
	1.系统行为单元直接进行处理，阻止不会产生行为单元的执行。但行为链的分析，判断需要
	先运行模式中的前部行为单元链，而这些行为本身会造成系统中数据的变化，这些变化可能
	会有破坏性，这些破坏性如何处理?进行还原，有几种实现方法?
	1.重定向技术(sandbox)，将所有的系统数据的变化进行收集处理，可以在行为链判断完成，
	阻止时，立即删除，也称虚拟机分析技术，是现代使用的病毒分析技术。
	2.记录所有的行为链数据，在阻止后，使用记录进行完全删除。

***********************************************************************************/

/**********************************************************************************
系统行为现象模式集：
1.解压文件的速度非常慢，硬盘有一些吱吱的寻道响声。它内部的系统行为细节为：
	1级细节分析
		1.解压程序会打开，读取源文件。
		2.解压程序将读取到内存的源文件数据进行解压运算，将运算数据拷贝至内存空间中。
		3.解压程序将解压好的内存中数据写入文件中。
	2级细节分析
		1.文件的打开过程：
			1.找到磁盘中文件所在的分区的区域。
			2.找到磁盘中文件所在区域。
			3.找到磁盘IO地址和中断号等通信资源，将数据与硬盘IO通信。
	3级细节分析
		1.文件系统驱动细节:
			WINDOWS支持的文件系统包括:
			1.fat32
			2.ntfs(包括几个不同版本)

			文件系统特征:

		2.磁盘驱动细节;
			
		3.总线驱动细节:

	4级细节分析
		1.实际的文件系统驱动
		 fastfat.sys
		 ntfs.sys
		2.实际代码细节分析:

	信息收集方法，收集点分析:
		1.文件系统访问点
		2.硬盘访问点

	通过对以上两个主要方面的功能的信息收集，可以判断出速度慢的原在硬盘硬件IO，硬盘访问
	功能，文件系统数据，文件系统解析，从而定位出问题原因，实际进行处理，或给用户相应
	的提示。

	定位用户需要处理关键系统行为问题模式，找到几十个模式，将模式综合处理为，BITSAFE
	的策略集，策略实现方式，比较方式，信息收集点，收集方法的方式。信息处理方法集，
	信息反馈用户方式等软件架构问题。

2.用户发现自己的最重要的数据被泄露。内部系统行为细节为：
	1.1级细节分析:
		1.某一破坏工作的进程的某一个线程，在某一个特定的时刻，读出用户保存的数据（在磁盘中，光盘，U盘等）。
		2.通过文件系统读取相应数据
		3.通过查询文件系统，搜索等方式，找出相应的硬盘扇区，将扇区中的数据读取出来。
		4.保护实现方法：
			1.对进程RING3层API进行hook
			2.对内核中的API进行HOOK
			3.对内核中的驱动进行过滤
			4.对内核中的中断，IO端口操作进行HOOK。

	2.保护所必须的相应的数据结构：
		1.进程白名单列表（对应某一种系统行为）。

	3.尽量提供最全面的最多样化的过滤信息支持。


**********************************************************************************/

/*********************************************************************************
1. 重定向功能的设计方案：
	1.WINDOWS 自带有UNC机制，是否可以使用这种机制或背后的架构来实现重定向。

**********************************************************************************/

/**********************************************************************************
简单行为链式匹配方法：
1.有序链，在一定的行为间隔次数中，如果发生了下个行为，则进入下个行为状态。如果没有，
则返回原始状态。
2.无序链，在一定的行为次数中，如果发生了所有的行为，则完成匹配。
相对而言，常常可以使用无序链来进行匹配。

**********************************************************************************/
/*
下一步要完成的关键工作：
1.确定简单行为链式策略匹配的实现方法。
2.设计开发重定向功能。
*/

/*
1.设计最简单的基于程序文件签名验证和关键系统数据行为的保护系统
2.不然开发的进度太慢。
*/

/*********************************************************************
sysdiag分析报告：
1.将功能分类，将每一类型的功能集，抽象为一个功能结构体，在DRIVERENTRY
中初始化所有的功能结构，DRIVERREINIT中再初始化，在DRIVERUNLOAD中，对所
有的功能结构进行卸载，在分析的SYSDIAG中包括了3个功能结构。

2.SYSDIAG在初始化过程中,分别加入了文件系统的MINIFILTER,内核SSDT HOOK,
TDI过滤设备,和WINDOWS系统的其它的重要的回调函数。

3.并且每一种功能结构都具有一套比较复杂的DEVICE IO CONTROL功能。

功能核心:
在回调函数中进行了什么数据结构的处理，行为报告过程是什么？
IO CONTORL过程中如何处理策略，策略的结构是什么？

*********************************************************************/

/*********************************************************************
智能化系统行为分析响应系统的设计步骤：
1.分析系统行为的宏观种类，形式。
2.分析系统行为的微观过程，步骤。
3.可能针对一种关键的行为进行反汇编分析。
4.提取关键的行为特征，将其转换为一种属性的数值。
5.将关键的属性数据+行为，转换一种可以某层次监测可以发现的数值。定制其
  为策略点，策略链。
6.将反应模式，做成反馈程序，或是使用通用的形式，如得到用户响应等。
*********************************************************************/

/*********************************************************************
精确的行为分析响应系统的运行过程将会是一种状态机系统。

最匹配的策略的形式和数值在还不同分析对象，过程，行为中是不同的。不应该
预置预想的策略，力求用它包含，进行一切行为分析。

*********************************************************************/
/*
行为的链的基本源是线程
线程的行为记录方案:
1.sysdiag实现方案
	1.每个线程都具有一个数据结构,其中一个链表记录策略链,和行为状态.
	2.
*/

NTSTATUS _check_sys_action( group_policy_nfa *nfa, 
						  action_source_info *source, 
						  r3_action_notify *action, 
						  policy_group_desc **desc )
{
	NTSTATUS ntstatus = STATUS_SUCCESS; 
	action_policy_type policy_type; 
	//event_action_response _resp = { 0 }; 

	do 
	{
		policy_type = action_2_policy_type( action->action.action.type ); 

		ntstatus = nfa_action_group_analyze( nfa, 
			source, 
			action, 
			desc ); 

		if( !NT_SUCCESS( ntstatus ) )
		{
			break; 
		}

	}while( FALSE ); 

_return:
	return ntstatus; 
 }

FORCEINLINE BOOLEAN group_policy_nfa_inited( group_policy_nfa *nfa )
{
	return TRUE; 
}

NTSTATUS check_sys_action( r3_action_notify *action, 
						   action_reply *resp )
{
	NTSTATUS ntstatus = STATUS_SUCCESS; 
	policy_group_desc *desc = NULL; 
	action_source_data source_data; 
	action_source_info *source = NULL;  

	do 
	{
		ASSERT( action != NULL ); 
		ASSERT( resp != NULL ); 
		ASSERT( TRUE == group_policy_nfa_inited( &group_nfa ) ); 

		source_data.proc = ( PVOID )( ULONG_PTR )action->action.ctx.proc_id; 
		source_data.thrd = ( PVOID )( ULONG_PTR )action->action.ctx.thread_id; 

		ntstatus = find_action_source( &source_data, &source ); 
		if( ntstatus != STATUS_SUCCESS )
		{
			break; 
		}

		ASSERT( source != NULL ); 

		ntstatus = _check_sys_action( &group_nfa, 
			source, 
			action, 
 			&desc ); 

		if( ntstatus != STATUS_SUCCESS )
		{
			break; 
		}

		ASSERT( desc != NULL ); 

		*resp = desc->reply; 

	}while( FALSE );

	if( source != NULL )
	{
		ASSERT( source->obj.ref_count >= 1 ); 

		deref_obj( &group_nfa.policy_groups, &source->obj ); 
	}

	if( desc != NULL ) 
	{
		FREE_TAG_POOL( desc ); 
	}

	return ntstatus; 
}

NTSTATUS init_action_check_context()
{
	NTSTATUS ntstatus = STATUS_SUCCESS; 
	BOOLEAN group_policy_dispatch_inited = FALSE; 
	BOOLEAN action_source_table_inited = FALSE; 
	BOOLEAN group_policy_nfa_inited = FALSE; 
	BOOLEAN action_policies_inited = FALSE; 

	do 
	{
		ntstatus = init_group_policy_dispatchs(); 
		if( ntstatus != STATUS_SUCCESS )
		{
			break;
		}

		group_policy_dispatch_inited = TRUE; 

		ntstatus = init_action_sources(); 
		if( ntstatus != STATUS_SUCCESS )
		{
			break; 
		}

		action_source_table_inited = TRUE; 

		ntstatus = init_group_policy_nfa( &group_nfa ); 
		if( ntstatus != STATUS_SUCCESS )
		{
			break; 
		}

		group_policy_nfa_inited = TRUE; 

		ntstatus = load_action_policies(); 
		if( ntstatus != STATUS_SUCCESS )
		{
			break; 
		}

		action_policies_inited = TRUE; 
	}while( FALSE );

	if( ntstatus != STATUS_SUCCESS )
	{
		if( group_policy_dispatch_inited == TRUE )
		{
			uninit_group_policy_dispatchs(); 
		}

		if( action_source_table_inited == TRUE )
		{
			uninit_action_sources(); 
		}


		if( group_policy_nfa_inited == TRUE )
		{
			uninit_group_policy_nfa( &group_nfa ); 
		}
	}

	return ntstatus; 
}

NTSTATUS uninit_action_check_context()
{
	NTSTATUS ntstatus = STATUS_SUCCESS; 

	do 
	{
		ntstatus = uninit_action_sources(); 
		if( ntstatus != STATUS_SUCCESS )
		{
			ASSERT( FALSE ); 
			log_trace( ( MSG_FATAL_ERROR, "uninit action sources error 0x%0.8x\n", ntstatus ) ); 
		}

		ntstatus = uninit_group_policy_nfa( &group_nfa ); 
		if( ntstatus != STATUS_SUCCESS )
		{
			ASSERT( FALSE ); 
			log_trace( ( MSG_FATAL_ERROR, "uninit group policy nfa error 0x%0.8x\n", ntstatus ) ); 
		}

	}while( FALSE ); 

	return ntstatus; 
}
/*************************************************************
第1版本开发计划：
1.实现应用层的行为链策略系统.
	1.从内核中截取出所有的有关于行为源，行为的数据。
	2.通过应用层对所有截取到的行为的分析，完成策略系统运行状态机。

2.进行各个方面的检证和完善 

3.从效率角度，特殊效果，功能角度出发，将部分策略运行机制移至内核态。
*************************************************************/

/*************************************************************
what do i want to do?
i want distinguish the all modified data 
( in disk, memory, network ) by the action in system.
*************************************************************/

/****************************************************************
实现安全保护的三种技术：
1.白名单
2.静态病毒库+静态杀毒引擎
3.动态行为分析

BITSAFE根本的研发方向是动态行为分析，如果可以设计出非常具有易用性
的白名单的话，也可以考虑对其进行研发。

静态分析的本质是对数据源，指令序列的数据体的特性进行分析，定位，
需要有相应静态库。

静态分析中现在还没有自动化代码分析技术，它的实现需要智能化技术，
当前还没有公开的出现这个技术。

白名单库也是静态的，需要建立静态库。它的静态库的灵活性，完善性，
将是它是否易用的关键。也是技术安突破的关键点。
白名单设计构想：
1.是否可以利用大量的人的分析，使用经验，建立一个非常灵活，完善的人
信白名单系统。
****************************************************************/

NTSTATUS load_test_policies()
{
	NTSTATUS ntstatus = STATUS_SUCCESS; 
	policy_group_desc *desc = NULL; 
	policy_group *group = NULL; 
	group_action_policy *policy; 

	do 
	{
		desc = ( policy_group_desc* )ALLOC_TAG_POOL( DEFAULT_POLICY_GROUP_LENGTH ); 

		if( desc == NULL )
		{
			ntstatus = STATUS_INSUFFICIENT_RESOURCES; 
			break; 
		}
#define TEST_POLICY_GROUP_DESC L"test"
		memcpy( desc->desc, TEST_POLICY_GROUP_DESC, sizeof( TEST_POLICY_GROUP_DESC ) ); 
		desc->desc_len = CONST_STR_LEN( TEST_POLICY_GROUP_DESC ) + 1; 
		desc->id = 0; 
		desc->level = 1; 
		desc->reply = ACTION_BLOCK; 

		ntstatus = add_policy_group( &group_nfa, 
			desc, 
			&group ); 

		if( ntstatus != STATUS_SUCCESS )
		{
			break; 
		}
		}
		}
		}

#define TEST_FILE_READ_POLICY_PATH L"\\Device\\HarddiskVolume1\\test\\1.txt"

		policy = malloc( sizeof( group_action_policy ) + ( _MAX_REG_PATH_LEN << 1 ) ); 
		if( policy == NULL )
		{
			log_trace( ( MSG_FATAL_ERROR, "allocate the buffer for policy loading error\n" ) ); 
			break; 
		}

		policy->policy.type = FILE_read; 
		policy->policy.do_file_read.offset = 0; 
		policy->policy.do_file_read.data_len = 0; 
		policy->policy.do_file_read.path_len = CONST_STR_LEN( TEST_FILE_READ_POLICY_PATH ); 
		policy->policy.size = FIELD_OFFSET( action_policy, do_file_read ) + sizeof( _file_read ) + sizeof( TEST_FILE_READ_POLICY_PATH ); 

		memcpy( policy->policy.do_file_read.path_name, TEST_FILE_READ_POLICY_PATH, sizeof( TEST_FILE_READ_POLICY_PATH ) ); 

		ntstatus = add_policy_to_group( &group_nfa, 
			&policy, 
			group ); 

		if( ntstatus != STATUS_SUCCESS )
		{
			break; 
		}

#define TEST_REG_KEY_PATH L"HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\WinSock2\\Parameters"
#define TEST_REG_VALUE_NAME	L"WinSock_Registry_Version"

		//ULONG type; //注册表值类型 
		//ULONG data_len; //数据长度 
		//PATH_SIZE_T path_len; 
		//PATH_SIZE_T val_name_len; 

		////NTSTATUS result; //动作完成结果(NTSTATUS) 
		//WCHAR path_name[ 1 ]; //注册表值路径 

		policy->policy.type = REG_getval; 
		policy->policy.do_reg_getval.type = REG_DWORD; 
		policy->policy.do_reg_getval.data_len = 4; 
		policy->policy.do_reg_getval.path_len = CONST_STR_LEN( TEST_REG_KEY_PATH ); 
		policy->policy.do_reg_getval.val_name_len = CONST_STR_LEN( TEST_REG_VALUE_NAME ); 

		memcpy( policy->policy.do_reg_getval.path_name, TEST_REG_KEY_PATH, sizeof( TEST_REG_KEY_PATH ) ); 
		policy->policy.do_reg_getval.path_len = CONST_STR_LEN( TEST_REG_VALUE_NAME ); 
		memcpy( ( policy->policy.do_reg_getval.path_name + policy->policy.do_reg_getval.path_len + 1 ), 
			TEST_REG_VALUE_NAME, 
			sizeof( TEST_REG_VALUE_NAME ) ); 

		policy->policy.size = FIELD_OFFSET( action_policy, do_reg_getval ) 
			+ sizeof( reg_getval ) 
			+ sizeof( TEST_REG_KEY_PATH ) 
			+ sizeof( TEST_REG_VALUE_NAME ); 

		ntstatus = add_policy_to_group( &group_nfa, 
			&policy, 
			group ); 

		if( ntstatus != STATUS_SUCCESS )
		{
			break; 
		}

	}while( FALSE );

	if( group != NULL )
	{
		deref_obj( &group_nfa.policy_groups, 
			&group->obj ); 
	}

	return ntstatus; 
}

NTSTATUS load_action_policies()
{
	NTSTATUS ntstatus = STATUS_SUCCESS; 

	do 
	{

#ifdef _DEBUG
		ntstatus = load_test_policies(); 
		if( ntstatus != STATUS_SUCCESS )
		{
			break; 
		}

#endif //_DEBUG
	}while( FALSE );

	return ntstatus; 
}
